/// <reference types="node" />
import JSBI from 'jsbi';
declare type AmountArg = Amount | JSBI | number | string;
/**
 * A wrapper around amounts with units.
 * Over the network, amounts are sent as raw bytes.
 * In the client, they are exposed as BigInts, but also compatible with plain strings or numbers (if smaller than 2^31-1)
 * Uses 'aergo' as default unit when passing strings or numbers.
 * Uses 'aer' as default unit when passing BigInts, buffers or byte arrays.
 * Whenever you pass amounts to other functions, they will try to coerce them to BigInt using this class.
 */
export default class Amount {
    value: Readonly<JSBI>;
    unit: string;
    private static _valueFromString;
    constructor(value: AmountArg | Buffer | Uint8Array, unit?: string, newUnit?: string);
    /**
     * Returns value as byte buffer
     */
    asBytes(): Buffer;
    /**
     * JSON.stringifes to string with unit aer, which can be easily deserialized by new Amount(x)
     */
    toJSON(): string;
    /**
     * Returns formatted string including unit
     */
    toString(): string;
    /**
     * Move decimal point in string by digits, positive to the right, negative to the left.
     * This extends the string if necessary.
     * Example: ("0.0001", 4 => "1"), ("0.0001", -4 => "0.00000001")
     * @param str
     * @param digits
     */
    static moveDecimalPoint(str: string, digits: number): string;
    formatNumber(unit?: string): string;
    /**
     * Convert to another unit
     * @param unit string (aer, gaer, aergo)
     */
    toUnit(unit: string): Amount;
    /**
     * Convert arg into JSBI value
     * Can optionally provide a defaultUnit that is used if arg does not contain a unit.
     */
    static toJSBI(arg: AmountArg, defaultUnit?: string): JSBI;
    /**
     * Compare this amount with other amount.
     * If otherAmount has no unit, assumes unit of this amount.
     * this >  other -> +1
     * this  < other -> -1
     * this == other -> 0
     * @param otherAmount
     */
    compare(otherAmount: AmountArg): number;
    /**
     * Return true if otherAmount is equal to this amount.
     * @param otherAmount
     */
    equal(otherAmount: AmountArg): boolean;
    /**
     * Add another amount to amount.
     * If otherAmount has no unit, assumes unit of this amount.
     * 10 aergo + 10 = 20 aergo
     * 10 aer + 10 = 20 aer
     * 10 aergo + 10 aer = 10.00000000000000001 aergo
     * @param otherAmount
     */
    add(otherAmount: AmountArg): Amount;
    /**
     * Subtract another amount from amount.
     * If otherAmount has no unit, assumes unit of this amount.
     * 10 aergo - 5 = 5 aergo
     * 10 aer - 5 = 5 aer
     * 1 aer - 1 aergo = -999999999999999999 aer
     * @param otherAmount
     */
    sub(otherAmount: AmountArg): Amount;
    /**
     * Divide amount by another amount.
     * Warning: double check your units. The division is based on the aer value, so
     * if your otherAmount has a unit, it will be converted to aer.
     * This function tries to do the right thing in regards to dividing units:
     * 10 aergo / 10 = 1 aergo  (keep unit)
     * 10 aergo / 10 aergo = 1  (unit-less)
     * 1 aer / 2 aer = 0  (truncation of sub 1 aer amount)
     * @param otherAmount
     */
    div(otherAmount: AmountArg): Amount;
    /**
     * Multiply amount by another amount.
     * Warning: double check your units. The multiplication is based on the aer value, so
     * if your otherAmount has a unit, it will be converted to aer.
     * However, while the value is correct, there's no way to display unit^2.
     * 10 aergo * 10 aergo = 10 * 10^18 aer * 10 * 10^18 aer = 100 * 10^36 aer = 100 * 10^18 aergo
     * 10 aergo * 10 = 10 * 10^18 aer * 10 = 100 * 10^18 aer = 100 aergo
     * @param otherAmount
     */
    mul(otherAmount: AmountArg): Amount;
}
export {};
