import { ByteEncoding, SignedAndHashedTxBody } from '@herajs/common';
import Accounts from '../accounts';
import { Staking, CommitStatus } from '../../types/rpc_pb';
import { Tx, Block, BlockMetadata, Peer, State, ChainInfo, Event, StateQueryProof, FilterInfo } from '../models';
import { Abi } from '../models/contract';
import { AddressInput } from '../models/address';
import { FunctionCall, StateQuery } from '../models/contract';
import { GetTxResult, GetReceiptResult, NameInfoResult, ConsensusInfoResult, ServerInfoResult, BlockBodyPaged, Stream, BasicType, JsonData, BlockchainResult, BatchTxResult } from './types';
export { CommitStatus };
/**
 * Main aergo client controller.
 */
declare class AergoClient {
    config: object;
    client: any;
    accounts: Accounts;
    target: string;
    private chainIdHash?;
    private defaultLimit;
    static defaultProviderClass?: {
        new (...args: any[]): any;
    };
    static platform: string;
    /**
     * Create a new auto-configured client with:
     *
     * .. code-block:: javascript
     *
     *     import AergoClient from '@herajs/client';
     *     const aergo = new AergoClient();
     *
     * @param [object] configuration. Unused at the moment.
     * @param [Provider] custom configured provider. By default a provider is configured automatically depending on the environment.
     */
    constructor(config?: {}, provider?: any);
    defaultProvider(): any;
    /**
     * Set a new provider
     * @param {Provider} provider
     */
    setProvider(provider: any): void;
    getConfig(): any;
    isConnected(): boolean;
    grpcMethod<I, O>(method: Function): (request: I) => Promise<O>;
    /**
     * Set the chain id hash to use for subsequent transactions.
     * @param hash string (base58 encoded) or byte array
     */
    setChainIdHash(hash: string | Uint8Array): void;
    /**
     * Set the default gas limit to use for transactions that do not define their own.
     */
    setDefaultLimit(limit: number): void;
    /**
     * Request chain id hash. This automatically gathers the chain id hash
     * from the current node if not specified.
     * @param enc set to 'base58' to retrieve the hash encoded in base58. Otherwise returns a Uint8Array.
     * @returns {Promise<Uint8Array | string>} Uint8Array by default, base58 encoded string if enc = 'base58'.
     */
    getChainIdHash(enc?: ByteEncoding): Promise<Uint8Array | string>;
    /**
     * Request current status of blockchain.
     * @returns {Promise<object>} an object detailing the current status
     */
    blockchain(): Promise<BlockchainResult>;
    /**
     * Request current status of blockchain.
     * @returns {Promise<object>} an object detailing the current status
     */
    getChainInfo(): Promise<ChainInfo>;
    /**
     * Request current status of node.
     * @returns {Promise<any>} an object detailing the state of various node components
     */
    getNodeState(component?: string, timeout?: number): Promise<any>;
    /**
     * Get transaction information in the aergo node.
     * If transaction is in the block return result with block hash and index.
     * @param {string} txhash transaction hash
     * @returns {Promise<object>} transaction details, object of tx: <Tx> and block: { hash, idx }
     */
    getTransaction(txhash: string): Promise<GetTxResult>;
    /**
     * Retrieve information about a block.
     *
     * @param hashOrNumber either 32-byte block hash encoded as a bs58 string or block height as a number.
     * @returns block details
     */
    getBlock(hashOrNumber: string | number): Promise<Block>;
    /**
     * Retrieve block metadata (excluding body).
     *
     * @param hashOrNumber either 32-byte block hash encoded as a bs58 string or block height as a number.
     * @returns block metadata
     */
    getBlockMetadata(hashOrNumber: string | number): Promise<BlockMetadata>;
    /**
     * Retrieve the last n blocks, beginning from given block
     *
     * @param {string|number} hashOrNumber either 32-byte block hash encoded as a bs58 string or block height as a number.
     * @param {number} size number of blocks to return
     * @param {number} offset number of blocks to skip
     * @param {boolean} desc order of blocks
     * @returns {Promise<Block[]>} list of block headers (blocks without body)
     */
    getBlockHeaders(hashOrNumber: string | number, size?: number, offset?: number, desc?: boolean): Promise<Block[]>;
    getBlockStream(): Stream<Block>;
    /**
     * Returns a stream of block metadata
     */
    getBlockMetadataStream(): Stream<BlockMetadata>;
    /**
     * Get the transactions of a block in a paged manner
     * @param hash
     * @param offset
     * @param size
     */
    getBlockBody(hashOrNumber: string | number, offset?: number, size?: number): Promise<BlockBodyPaged>;
    /**
     * Returns a stream that yields new events matching the specified filter in real-time.
     *
     * .. code-block:: javascript
     *
     *      const stream = aergo.getEventStream({
     *          address: 'Am....'
     *      });
     *      stream.on('data', (event) => {
     *         console.log(event);
     *         stream.cancel();
     *      });
     *
     * @param {FilterInfo} filter :class:`FilterInfo`
     * @returns {Stream<Event>} event stream
     */
    getEventStream(filter: Partial<FilterInfo>): Stream<Event>;
    /**
     * Retrieve account state, including current balance and nonce.
     * @param {string} address Account address encoded in Base58check
     * @returns {Promise<object>} account state
     */
    getState(address: AddressInput): Promise<State>;
    /**
     * Retrieve account's most recenlty used nonce.
     * This is a shortcut function as the same information is also returned by getState.
     * @param {string} address Account address encoded in Base58check
     * @returns {Promise<object>} account state
     */
    getNonce(address: AddressInput): Promise<number>;
    /**
     * Send one or more signed transaction to the network.
     * @param {Tx} tx signed transaction or array of multiple signed transactions
     * @returns {Promise<string>} transaction hash
     */
    sendSignedTransaction(tx: Tx | SignedAndHashedTxBody): Promise<string>;
    sendSignedTransaction(tx: (Tx | SignedAndHashedTxBody)[]): Promise<BatchTxResult[]>;
    /**
     * Return the top {count} result for a vote
     * @param count number
     * @param id vote identifier, default: voteBP
     */
    getTopVotes(count: number, id?: string): Promise<any>;
    /**
     * Return the top voted-for block producer or system parameter
     * @param address string
     */
    getAccountVotes(address: AddressInput): Promise<any>;
    /**
     * Return information for account name
     * @param {string} address Account address encoded in Base58check
     */
    getStaking(address: AddressInput): Promise<Staking.AsObject>;
    /**
     * Retrieve the transaction receipt for a transaction
     * @param {string} txhash transaction hash
     * @return {Promise<object>} transaction receipt
     */
    getTransactionReceipt(txhash: string): Promise<GetReceiptResult>;
    /**
     * Retrieve the transaction receipt for a transaction, but keep retrying if not available yet.
     * Uses expoinential backoff and a final timeout.
     * @param {string} txhash transaction hash
     * @param {number} timeout throws error when timeout is reached
     * @param {number} baseBackoffInterval base time for exponentail backoff
     * @return {Promise<object>} transaction receipt
     */
    waitForTransactionReceipt(txhash: string, timeout?: number, baseBackoffInterval?: number): Promise<GetReceiptResult>;
    /**
     * Query contract ABI
     * @param {FunctionCall} functionCall call details
     * @returns {Promise<object>} result of query
     */
    queryContract(functionCall: FunctionCall): Promise<any>;
    /**
     * Query contract state.
     * This only works for variables explicitly defines as state variables.
     * Throws when contract do not exist, or when variable does not exist when requesting single key.
     * @param {StateQuery} stateQuery query details obtained from contract.queryState()
     * @returns {Promise<JsonData>} result of query: single value if requesting one key, list of values when requesting multiple keys.
     */
    queryContractState(stateQuery: StateQuery): Promise<JsonData | BasicType>;
    /**
     * Query contract state, including proofs.
     * This only works vor variables explicitly defines as state variables.
     * @param {StateQuery} stateQuery query details obtained from contract.queryState()
     * @returns {Promise<StateQueryProof>} result of query, including account and var proofs
     */
    queryContractStateProof(stateQuery: StateQuery): Promise<StateQueryProof>;
    /**
     * Query contract state
     * This only works vor variables explicitly defines as state variables.
     * @param {FilterInfo} filter :class:`FilterInfo`
     * @returns {Event[]} list of events
     */
    getEvents(filter: Partial<FilterInfo>): Promise<Event[]>;
    /**
     * Query contract ABI
     * @param {string} address of contract
     * @returns {Promise<object>} abi
     */
    getABI(address: AddressInput): Promise<Abi>;
    /**
     * Get list of peers of connected node
     */
    getPeers(showself?: boolean, showhidden?: boolean): Promise<Peer[]>;
    /**
     * Return information for account name
     * @param name
     */
    getNameInfo(name: string, blockno?: number): Promise<NameInfoResult>;
    /**
     * Return consensus info. The included fields can differ by consensus type.
     */
    getConsensusInfo(): Promise<ConsensusInfoResult>;
    /**
     * Return server info
     */
    getServerInfo(keys?: string[]): Promise<ServerInfoResult>;
}
export default AergoClient;
