export declare const errorMessageForCode: (code: number) => string;
/**
 * Keep calling a function until it does not throw and also satifies check(result), or until timeout is reached
 * @param func function to be called. Can return a promise.
 * @param check function that is called on func's result
 * @param timeout duration after which polling times out
 * @param wait duration between calls
 */
export declare const longPolling: <T>(func: () => Promise<T>, check?: <T>(result: T) => boolean, timeout?: number, wait?: number) => Promise<T>;
declare type PromiseFunction<I = any, O = any> = (n: I) => Promise<O>;
declare type WaterfallFunction<FirstI, LastO> = (input: FirstI) => Promise<LastO>;
export declare function waterfall<I extends any, O1 extends any, O2 extends any, O3 extends any, O4 extends any, O5 extends any>(fns: [PromiseFunction<I, O1>, PromiseFunction<O1, O2>, PromiseFunction<O2, O3>, PromiseFunction<O3, O4>, PromiseFunction<O4, O5>]): WaterfallFunction<I, O5>;
export declare function waterfall<I extends any, O1 extends any, O2 extends any, O3 extends any, O4 extends any>(fns: [PromiseFunction<I, O1>, PromiseFunction<O1, O2>, PromiseFunction<O2, O3>, PromiseFunction<O3, O4>]): WaterfallFunction<I, O4>;
export declare function waterfall<I extends any, O1 extends any, O2 extends any, O3 extends any>(fns: [PromiseFunction<I, O1>, PromiseFunction<O1, O2>, PromiseFunction<O2, O3>]): WaterfallFunction<I, O3>;
export declare function waterfall<I extends any, O1 extends any, O2 extends any>(fns: [PromiseFunction<I, O1>, PromiseFunction<O1, O2>]): WaterfallFunction<I, O2>;
export declare function waterfall<I extends any, O1 extends any>(fns: [PromiseFunction<I, O1>]): WaterfallFunction<I, O1>;
export {};
